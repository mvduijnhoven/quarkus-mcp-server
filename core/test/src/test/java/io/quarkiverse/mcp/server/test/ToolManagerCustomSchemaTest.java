package io.quarkiverse.mcp.server.test;

import io.quarkiverse.mcp.server.ToolManager;
import io.quarkiverse.mcp.server.runtime.ToolManagerImpl;
import io.quarkiverse.mcp.server.test.config.CustomTestSchemaModule;
import io.quarkus.test.QuarkusUnitTest;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;
import jakarta.validation.constraints.NotNull;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.github.victools.jsonschema.generator.SchemaGenerator;
import com.github.victools.jsonschema.generator.SchemaGeneratorConfig;
import com.github.victools.jsonschema.module.jakarta.validation.JakartaValidationModule;
import com.github.victools.jsonschema.module.jakarta.validation.JakartaValidationOption;

import java.lang.reflect.Field;

public class ToolManagerCustomSchemaTest {

    @RegisterExtension
    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()
            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)
                    .addClasses(CustomTestSchemaModule.class, TestTool.class, TestTool.InputArgs.class)
                    // Ensure Jackson and Jakarta Validation modules are available for this test
                    .addAsResource("application.properties"));

    @Inject
    ToolManager toolManager;

    @Inject
    Instance<CustomTestSchemaModule> customTestSchemaModuleInstance;


    @BeforeEach
    public void reset() {
        CustomTestSchemaModule.invoked = false;
    }

    public static class TestTool {
        public static class InputArgs {
            @NotNull
            @JsonPropertyDescription("A required name")
            public String name;

            public int age;
        }

        public String myTool(InputArgs args) {
            return "Hello " + args.name;
        }
    }

    @Test
    public void testCustomizerIsInvokedAndSchemaReflectsCustomization() throws Exception {
        // Ensure the customizer instance is available
        Assertions.assertFalse(customTestSchemaModuleInstance.isUnsatisfied(), "CustomTestSchemaModule should be available");
        customTestSchemaModuleInstance.get(); // Initialize the bean to ensure its logic runs if it's lazy

        toolManager.newTool("testCustomTool")
                .description("A test tool with custom schema")
                .setFunction(TestTool.class, "myTool", TestTool.InputArgs.class, String.class)
                .register();

        ToolManager.ToolInfo toolInfo = toolManager.getTool("testCustomTool");
        Assertions.assertNotNull(toolInfo, "Tool should be registered");

        // Verify the customizer was invoked
        Assertions.assertTrue(CustomTestSchemaModule.invoked, "CustomTestSchemaModule.customize() should have been invoked.");

        // Check that the schema reflects the @NotNull annotation (via JakartaValidationModule with custom option)
        // This requires inspecting the schema generated by ToolManagerImpl
        // We need to access the SchemaGenerator inside ToolManagerImpl or replicate its setup for verification

        // Access the schema generator config for verification
        Field schemaGeneratorField = ToolManagerImpl.class.getDeclaredField("schemaGenerator");
        schemaGeneratorField.setAccessible(true);
        SchemaGenerator schemaGenerator = (SchemaGenerator) schemaGeneratorField.get(toolManager);
        SchemaGeneratorConfig config = schemaGenerator.getConfig();

        Assertions.assertTrue(config.getModule(JakartaValidationModule.class) != null, "JakartaValidationModule should be configured");
        Assertions.assertTrue(config.getModule(JakartaValidationModule.class).getOptions().contains(JakartaValidationOption.NOT_NULLABLE_FIELD_IS_REQUIRED), "Custom JakartaValidationOption should be set");

        // More direct check on the generated schema (if possible through ToolInfo)
        // This part might need adjustment based on how ToolInfo exposes schema details
        String schemaJson = toolInfo.asJson().getJsonObject("inputSchema").toString();
        Assertions.assertTrue(schemaJson.contains("\"required\":[\"name\"]"), "Schema should mark 'name' as required due to @NotNull and customizer");
        System.out.println("Schema: " + schemaJson);
    }
}
